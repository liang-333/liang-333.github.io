[{"content":"请求方法 get：从服务器获取数据，不对服务器资源产生影响，请求参数会作为请求参数URL的一部分发送。\npost：向服务器发送数据，会对服务器资源产生影响，请求参数在请求体中且对长度没有限制，请求的参数类型在信息头\u0026quot;Content-Type\u0026quot;。\n请求返回数据(请求response)：\ntext response.text 二进制 response.content json respons.json() 参数 解释 url 必选项，请求网址，字符串 headers 请求头，字典 params 查询参数，字典 data post请求参数，一般为字典 json 参数，字典 cookies 字典，用户身份信息 proxies IP代理 params查看 post请求参数查看 ","date":"2023-11-06T00:00:00Z","image":"https://liang-333.github.io/img/2.jpg","permalink":"https://liang-333.github.io/p/requests%E8%AF%B7%E6%B1%82%E5%A4%B4/","title":"requests请求头"},{"content":"css选择器 1 2 3 4 import parsel # response.text字符串转换为可进行css选择语法的对象 selector = parsel.Selector(response.text) get() 获取满足条件的第一个元素，获取的元素内容有空格会出现只读取部分的情况，返回第一部分内容。 getall() 获取所有满足条件的元素内容，返回一个列表。\n语法 css选择器 描述 例子 .class html元素的属性 #id html元素的id * 选择所有元素 * element 所有的element element1,element2 所有的element1和element2 element1 element2 所有element1里面的element2 element1 element2 父元素为element1里面的element2 [attribute] 含有属性attribute的所有元素 伪类选择器 伪类选择器 描述 :last-of-type 满足条件的最后一个元素 :not(selector) 除了selector以外的元素 :nth-child(n) 满足条件的第n个元素 :nth-last-child(n) 满足条件的倒数第n个元素 属性选择器 属性提取 ::text ::attr(attribute) ","date":"2023-11-05T00:00:00Z","image":"https://liang-333.github.io/img/1.jpg","permalink":"https://liang-333.github.io/p/css%E9%80%89%E6%8B%A9%E5%99%A8/","title":"css选择器"},{"content":"内容写入 excel openpyxl 库读写excel，操作由三个对象完成\nworkbook： 工作簿，一个多个sheet。\nsheet：工作表，如“sheet1”，“sheet2”等。\ncell： 单元格，存储数据对象\n新建 1 2 3 4 5 6 7 8 9 10 11 12 13 from openpyxl import Workbook # 创建工作簿 wb = Workbook() # 获取当前活动表，工作簿默认自带一张表 sheet = wb.active # 活动表表名 print(wb.active.title) sheet.title = \u0026#39;表1\u0026#39; # 创建新表 sheet2 = wb.create_sheet(\u0026#39;表2\u0026#39;) # 通过表名获取表 sheet1 = wb[\u0026#39;表1\u0026#39;] 读写 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # 按单元格位置写入值 sheet[\u0026#39;A1\u0026#39;] = 42 sheet.cell(row=2, column=5).value = 99 sheet.cell(row=3, column=5, value=100) # 逐行追加 # ws.append(iterable) # iterable必须是list,tuple,dict,range,generator类型的。 # 1，如果是list，则按行将list从头到尾顺序添加。 # 2，如果是dict，按照相应的键添加相应的键值。 ws.append([\u0026#39;A1\u0026#39;,\u0026#39;B1\u0026#39;,\u0026#39;C1\u0026#39;]) ws.append({\u0026#39;A\u0026#39;: \u0026#39;A1\u0026#39;， \u0026#39;C\u0026#39;: \u0026#39;C1\u0026#39;}) ws.append({1: \u0026#39;A1\u0026#39;， 3: \u0026#39;C1\u0026#39;}) # 获取行数和列数： rows = table.max_row cols = table.max_column # 获取所有表名 sheet_names = wb.sheetnames wb.save(\u0026#34;sample1.xlsx\u0026#34;) json 与字典相比，值用的是双引号\u0026quot; \u0026quot;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 data = { \u0026#39;name\u0026#39;: \u0026#39;李雷\u0026#39;, \u0026#39;age\u0026#39;: 20, \u0026#39;address\u0026#39;: \u0026#39;广西\u0026#39; } # json序列号，字典数据变为json json_str = json.dumps(data) # 中文解决办法 json_str = json.dumps(data， ensure_ascii=False) # 读取 json 数据 with open(\u0026#39;data.json\u0026#39;, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: # 反序列化，json数据变为字典类型 data = json.load(f) csv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 import csv ll = [[1, 2, 3, 4], [1, 2, 3, 4], [5, 6, 7, 8], [5, 6, 7, 8]] # 有可能出现文件每一行后面会多一个空行。使用 newline=\u0026#39;\u0026#39;解决 with open(\u0026#39;test.csv\u0026#39;, \u0026#39;w\u0026#39;, newline=\u0026#39;\u0026#39;) as csvfile: \u0026#34;\u0026#34;\u0026#34; delimiter: 分割符 \u0026#34;\u0026#34;\u0026#34; csv_writer = csv.writer(csvfile, delimiter=\u0026#39;,\u0026#39;) for l in ll: spamwriter.writerow([1, 2, 3, 4]) # 读取 with open(\u0026#39;example.csv\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: csv_reader = csv.reader(f) for row in csv_reader: print(row) # 写入字典 with open(\u0026#39;test.csv\u0026#39;, \u0026#39;w\u0026#39;) as csvfile: fieldnames = [\u0026#39;first_name\u0026#39;, \u0026#39;last_name\u0026#39;] writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() writer.writerow({\u0026#39;first_name\u0026#39;: \u0026#39;lilei\u0026#39;, \u0026#39;last_name\u0026#39;: \u0026#39;lisa\u0026#39;}) # 读取字典 with open(\u0026#39;test.csv\u0026#39;, newline=\u0026#39;\u0026#39;) as csvfile: reader = csv.DictReader(csvfile) for row in reader: print(row[\u0026#39;first_name\u0026#39;], row[\u0026#39;last_name\u0026#39;]) ","date":"2023-11-05T00:00:00Z","image":"https://liang-333.github.io/img/4.jpg","permalink":"https://liang-333.github.io/p/%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98/","title":"数据写入excel/csv/json"},{"content":"文件操作 copy.copy 浅拷贝 只拷贝父对象，不会拷贝内部的子对象。 copy.deepcopy 深拷贝 拷贝对象及其子对象\n1、文件打开 文件打开模式 模式 描述 r 以只读方式打开文件，文件的指针在文件的开头。 rb 以二进制格式只读打开文件，同r。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式读写打开文件，同r+。 w 打开一个文件只用于写入，如果文件存在则打开文件并从开头开始编辑，原有内容会被删除。如果该文件不存在，则创建新文件。 wb 以二进制格式打开一个文件只用于写入，同w。 w+ 打开一个文件用于读写，如果该文件已存在则打开文件并从开头开始编辑，原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写，同w+。 a 打开一个文件用于追加，如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加，同a。 a+ 打开一个文件用于读写，如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加，同a+。 文件打开方式 1、使用open直接打开文件，打开后必须close()，不推荐使用，推荐使用withopen\n1 2 3 4 5 6 7 8 # 打开文件 f = open(\u0026#39;test.txt\u0026#39;, \u0026#39;w\u0026#39;) # f.read(num)，从文件中读取的数据长度num，默认读所有 # f.readlines()，将文件内容一次性读取，并且返回一个列表，每一行最后的换行符\\n也会读入 # f.readline()，一次读取一行内容 # 文件写入f.write(str) # 关闭文件 f.close() 2、withopen打开文件\n1 2 with open(\u0026#39;test.txt\u0026#39;, mode=\u0026#39;r+\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as f: content = f.read() 文件夹及目录操作 OS文件及目录操作 方法 说明 os.mkdir 创建目录 os.rmdir 删除目录 os.rename 重命名文件 os.remove 删除文件 os.getcwd 获取当前工作路径 os.chdir 修改当前工作目录 os.path 路径操作 方法 说明 os.path.join 连接目录与文件名 os.path.split 分割文件名与目录 os.path.abspath 获取绝对路径 os.path.dirname 获取路径 os.path.basename 获取文件名或文件夹名 os.path.splitext 分离文件名与扩展名 os.path.isfile 判断给出的路径是否是一个文件 os.path.isdir 判断给出的路径是否是一个目录 os.path.exists 检查文件是否存在 ","date":"2023-11-05T00:00:00Z","image":"https://liang-333.github.io/img/5.jpg","permalink":"https://liang-333.github.io/p/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","title":"文件常用指令"},{"content":"正则表达式 1 2 # 导入库 import re re函数用法 pattern是规则，特殊字符需要反斜杠转义、string是需要匹配的字符串，maxsplit切割的次数，repl需要替换为的字符串，count替换次数\n函数 解释 返回值 match(pattern， string[， flag]) 从字符串头部开始查找，也可以指定起始位置，只匹配一次，找到匹配结果就返回 匹配到则返回一个Match对象，无则返回none search(pattern， string[， flag]) 查找字符串的任何位置，也是一次匹配，匹配到就返回 匹配到则返回一个Match对象，无则返回none findall(pattern， string[， flag]) 匹配任何位置，所有匹配的字符串，返回列表 返回列表，无则返回空列表 split(pattern， string[， maxsplit， flags]) 该局匹配到的子字符串将整个string分割，去掉匹配到的字符串，返回列表 返回列表 sub(pattern， repl， string[， count， flags]) 将匹配的字符串替换 返回替换后的字符串 compile() 将正则表达式的字符串形式编译为一个 Pattern对象 不用重复写正则表达式，编译一次可以抑制使用，提高效率 贪婪和非贪婪 默认贪婪，尽可能多的匹配。?表示非贪婪，尽可能少的匹配字符。\n元字符 使用元字符匹配单个字符\n字符 功能 示例 . 匹配任意1个字符（除了\\n），需要匹配的话加入re.S .* [ ] 匹配[ ]中列举的字符 [a-z] \\d 匹配数字，即0-9 [\\d] \\D 匹配非数字，即不是数字 \\s 匹配空白，即 空格，tab键，换行 \\S 匹配非空白（数字、英文字符、特殊符号） \\w 匹配单词字符，即a-z、A-Z、0-9、_ \\W 匹配非单词字符 * 匹配前一个字符出现0次或者无数次，即可有可无 .*? 其他 字符 功能 {m} 匹配前一个字符出现了m次 [0-9]{11} {m,n} 匹配前一个字符出现从m到n次 [0-9]{5,11}@qq.com 字符 功能 示例 ^ 匹配字符串开头 \u0026quot;^http$\u0026quot; $ 匹配字符串结尾 \u0026quot;[\\w]{5，11}@qq\\.com$\u0026quot; ","date":"2023-11-05T00:00:00Z","image":"https://liang-333.github.io/img/6.jpg","permalink":"https://liang-333.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","title":"正则表达式"}]